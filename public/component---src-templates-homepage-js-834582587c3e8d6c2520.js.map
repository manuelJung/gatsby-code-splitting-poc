{"version":3,"sources":["webpack:///./src/templates/Homepage.js","webpack:///./.cache/public-page-renderer.js","webpack:///./.cache/gatsby-browser-entry.js","webpack:///./.cache/public-page-renderer-prod.js"],"names":["__webpack_require__","r","__webpack_exports__","d","Homepage","react__WEBPACK_IMPORTED_MODULE_0__","styled_components__WEBPACK_IMPORTED_MODULE_1__","gatsby__WEBPACK_IMPORTED_MODULE_2__","_ref","widgets","Wrapper","className","WidgetExample1","WidgetExample2","to","styled","div","withConfig","displayName","componentId","m","module","exports","require","default","react__WEBPACK_IMPORTED_MODULE_0___default","n","gatsby_link__WEBPACK_IMPORTED_MODULE_1__","gatsby_link__WEBPACK_IMPORTED_MODULE_1___default","a","loader","enqueue","React","createContext","ProdPageRenderer","location","pageResources","createElement","InternalPageRenderer","Object","assign","json"],"mappings":"0FAAAA,EAAAC,EAAAC,GAAAF,EAAAG,EAAAD,EAAA,4BAAAE,IAAA,IAAAC,EAAAL,EAAA,GAAAM,EAAAN,EAAA,KAAAO,EAAAP,EAAA,KAIe,SAASI,EAATI,GAA8B,IAAVC,EAAUD,EAAVC,QACjC,OACEJ,EAAA,cAACK,EAAD,CAASC,UAAU,YACjBN,EAAA,qDACAA,EAAA,6QAOAA,EAAA,uBACEA,EAAA,yOAOFA,EAAA,wFAIAA,EAAA,cAACI,EAAQG,eAAT,MACAP,EAAA,cAACI,EAAQI,eAAT,MAEAR,EAAA,oFAEMA,EAAA,kCAFN,gOAK2CA,EAAA,mCAL3C,4BASAA,EAAA,+MAGgCA,EAAA,oDAHhC,uFAOAA,EAAA,wBACEA,EAAA,wBAAIA,EAAA,cAACE,EAAA,EAAD,CAAMO,GAAG,iBAAT,WACJT,EAAA,wBAAIA,EAAA,cAACE,EAAA,EAAD,CAAMO,GAAG,iBAAT,YAGNT,EAAA,8SAOAA,EAAA,mPAGiDA,EAAA,2BAMvD,IAAMK,EAAUK,IAAOC,IAAVC,WAAA,CAAAC,YAAA,oBAAAC,YAAA,YAAGJ,CAAH,0GCnEb,IAAsBK,EAKpBC,EAAOC,SALaF,EAKWG,EAAQ,OALRH,EAAEI,SAAYJ,oCCA/C,IAAAf,EAAAL,EAAA,GAAAyB,EAAAzB,EAAA0B,EAAArB,GAAAsB,EAAA3B,EAAA,IAAA4B,EAAA5B,EAAA0B,EAAAC,GAAA3B,EAAAG,EAAAD,EAAA,sBAAA0B,EAAAC,IAAA7B,EAAA,KAAAA,EAAA,IAcyB8B,QAAOC,QAELC,IAAMC,cAAc,gFCMhCC,UAjBU,SAAA1B,GAAiC,IAA9B2B,EAA8B3B,EAA9B2B,SAAUC,EAAoB5B,EAApB4B,cACpC,OAAKA,EAGEJ,IAAMK,cAAcC,IAApBC,OAAAC,OAAA,CACLL,WACAC,iBACGA,EAAcK,OALV","file":"component---src-templates-homepage-js-834582587c3e8d6c2520.js","sourcesContent":["import * as React from 'react'\nimport styled from 'styled-components'\nimport {Link} from 'gatsby'\n\nexport default function Homepage ({widgets}) {\n  return (\n    <Wrapper className='Homepage'>\n      <h1>Gatsby Code-Splitting POC</h1>\n      <p>\n        Welcome to the gatsby code splitting POC. Here I will describe a\n        way how we could code-split dynamic react components. Normally gatsby\n        splits code by pages. That is fine for most use-cases. But there is one\n        situation where this does not work: \n      </p>\n\n      <p>\n        <b>\n          Based on cms data like json, markdown or any data from an api that relies\n          on specific react-components we have to add all possible components into the\n          bundle to archieve an correct prerendering of the page\n        </b>\n      </p>\n\n      <p>\n        Following are some components that are already code-splitted:\n      </p>\n\n      <widgets.WidgetExample1/>\n      <widgets.WidgetExample2/>\n\n      <p>\n        These widgets are manually added in gatsby-node under \n        the <b>widgets</b> key. All these widgets are added to the page \n        and won't get added to any other page. When you build the app\n        you can see, that these widgets are added as an async script to the dom\n        and are loaded seperatly with the prefix <b>widget--</b>. Check your network\n        tab\n      </p>\n\n      <p>\n        That is an very basic example and won't happen in real apps. So let's get\n        more realistic: We create some blog posts that can render custom components.\n        I've created some posts under <b>src/cms/posts/[post].json</b>.\n        These posts are picked um by the graphql-layer and we create pages for each post:\n      </p>\n\n      <ul>\n        <li><Link to='/posts/post-1'>Post 1</Link></li>\n        <li><Link to='/posts/post-2'>Post 2</Link></li>\n      </ul>\n\n      <p>\n        If you inspect the network you can see, that all widgets that are used by my\n        posts are injected with a preload flag. that is done similar than gatsby preloads\n        pages. When you click on a post the post will only render when all widgets are\n        fetched --- just like page-components\n      </p>\n\n      <p>\n        Some interresting feature that is missing is, that we could enable \"widget-queries\"\n        just like normal page queries. That could be a killer feature because it could enable\n        dyamic queries deep within your component tree.<br/>\n      </p>\n    </Wrapper>\n  )\n}\n\nconst Wrapper = styled.div`\n  padding: 20px;\n  max-width: 800px;\n  margin: 0 auto;\n  text-align: center;\n  p {\n    font-size: 18px;\n  }\n`","const preferDefault = m => (m && m.default) || m\n\nif (process.env.BUILD_STAGE === `develop`) {\n  module.exports = preferDefault(require(`./public-page-renderer-dev`))\n} else if (process.env.BUILD_STAGE === `build-javascript`) {\n  module.exports = preferDefault(require(`./public-page-renderer-prod`))\n} else {\n  module.exports = () => null\n}\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\nimport Link, {\n  withPrefix,\n  withAssetPrefix,\n  navigate,\n  push,\n  replace,\n  navigateTo,\n  parsePath,\n} from \"gatsby-link\"\nimport PageRenderer from \"./public-page-renderer\"\nimport loader from \"./loader\"\n\nconst prefetchPathname = loader.enqueue\n\nconst StaticQueryContext = React.createContext({})\n\nfunction StaticQueryDataRenderer({ staticQueryData, data, query, render }) {\n  const finalData = data\n    ? data.data\n    : staticQueryData[query] && staticQueryData[query].data\n\n  return (\n    <React.Fragment>\n      {finalData && render(finalData)}\n      {!finalData && <div>Loading (StaticQuery)</div>}\n    </React.Fragment>\n  )\n}\n\nconst StaticQuery = props => {\n  const { data, query, render, children } = props\n\n  return (\n    <StaticQueryContext.Consumer>\n      {staticQueryData => (\n        <StaticQueryDataRenderer\n          data={data}\n          query={query}\n          render={render || children}\n          staticQueryData={staticQueryData}\n        />\n      )}\n    </StaticQueryContext.Consumer>\n  )\n}\n\nconst useStaticQuery = query => {\n  if (\n    typeof React.useContext !== `function` &&\n    process.env.NODE_ENV === `development`\n  ) {\n    throw new Error(\n      `You're likely using a version of React that doesn't support Hooks\\n` +\n        `Please update React and ReactDOM to 16.8.0 or later to use the useStaticQuery hook.`\n    )\n  }\n  const context = React.useContext(StaticQueryContext)\n  if (context[query] && context[query].data) {\n    return context[query].data\n  } else {\n    throw new Error(\n      `The result of this StaticQuery could not be fetched.\\n\\n` +\n        `This is likely a bug in Gatsby and if refreshing the page does not fix it, ` +\n        `please open an issue in https://github.com/gatsbyjs/gatsby/issues`\n    )\n  }\n}\n\nStaticQuery.propTypes = {\n  data: PropTypes.object,\n  query: PropTypes.string.isRequired,\n  render: PropTypes.func,\n  children: PropTypes.func,\n}\n\nfunction graphql() {\n  throw new Error(\n    `It appears like Gatsby is misconfigured. Gatsby related \\`graphql\\` calls ` +\n      `are supposed to only be evaluated at compile time, and then compiled away. ` +\n      `Unfortunately, something went wrong and the query was left in the compiled code.\\n\\n` +\n      `Unless your site has a complex or custom babel/Gatsby configuration this is likely a bug in Gatsby.`\n  )\n}\n\nexport {\n  Link,\n  withAssetPrefix,\n  withPrefix,\n  graphql,\n  parsePath,\n  navigate,\n  push, // TODO replace for v3\n  replace, // TODO remove replace for v3\n  navigateTo, // TODO: remove navigateTo for v3\n  StaticQueryContext,\n  StaticQuery,\n  PageRenderer,\n  useStaticQuery,\n  prefetchPathname,\n}\n","import React from \"react\"\nimport PropTypes from \"prop-types\"\n\nimport InternalPageRenderer from \"./page-renderer\"\n\nconst ProdPageRenderer = ({ location, pageResources }) => {\n  if (!pageResources) {\n    return null\n  }\n  return React.createElement(InternalPageRenderer, {\n    location,\n    pageResources,\n    ...pageResources.json,\n  })\n}\n\nProdPageRenderer.propTypes = {\n  location: PropTypes.shape({\n    pathname: PropTypes.string.isRequired,\n  }).isRequired,\n}\n\nexport default ProdPageRenderer\n"],"sourceRoot":""}